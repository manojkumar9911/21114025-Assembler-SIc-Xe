#include<bits/stdc++.h>
using namespace std;
void regtab_init();
//structs
struct optab_struct{
int format;
string opcode;
bool exists;
optab_struct(){
    format=-1;
    opcode="FF";
    exists=false;
}
};
struct symtab_struct{
    int address;
    bool exists;
    bool isRelative;
    symtab_struct(){
        address=-3;
        exists=false;
        isRelative=false;
    }
};
struct REG_TAB_struct{
    int value;
    bool exists;
    int number;
    REG_TAB_struct(){
        value=0;
        number=-1;
        exists=false;
    }
};
struct littab2_struct{
    string name;
    string value;
    bool exists;
    littab2_struct(){
        name="";
        value="";
        exists=false;
    }
};
struct extdef_struct{
  string name;
  string address;
  bool exists;
  extdef_struct()
  {
    name = "undefined";
    address = "0";
    exists = false;
  }
};
struct extref_struct{
  string name;
  bool exists;
  extref_struct(){
    name = "undefined";
    exists = false;
  }
};
struct csect_struct{    
  string name;
  string LOCCTR;
  int section_number;
  int length;
  map<string, extdef_struct> EXTDEF_TAB;
  map<string, extref_struct> EXTREF_TAB;
  map<string, symtab_struct> SYM_TAB;
  map<string,littab2_struct> LIT_TAB;
  csect_struct()
  { regtab_init();
    name = "DEFAULT";
    LOCCTR = "0";
    section_number = 0;
    length = 0;
  }
};
//Global shared data
map<string,optab_struct> OP_TAB;
map<string,REG_TAB_struct> REG_TAB;
map<string,csect_struct> CSECT;
//utility
int convertHexToDec(string hexString){
  stringstream stream;
  int dec;
  stream << hexString;
  stream >> hex >> dec;
  return dec;
}
int convertStringToInt(string str){
    int value;
    stringstream(str) >> value;
    return value;
}
string convertDecToHex(int decimal){
    stringstream stream2;
    stream2 << hex << decimal;
    string result(stream2.str());
    char resultUpper[10];
    strcpy(resultUpper, result.c_str());
    for (int i = 0 ; i < strlen(resultUpper) ; i++){
        resultUpper[i] = toupper(resultUpper[i]);
    }
    return resultUpper;
}
string convertHexToBin(string text){
    int no = 0;
    string binaryResult = "";
    for (int i = 0 ; i < text.length() ; i++){
        string temp = "";
        if (text[i] >= '0' && text[i] <= '9'){
            no = int(text[i]) - 48;
            while (no > 0){
                temp += char(no % 2 + 48);
                no /= 2;
            }
            while (temp.length() != 4){
                temp += '0';
            }
            no = 0;
        }
        else {
            no = text[i] - 'A' + 10;
            while (no > 0){
                temp += char(no % 2 + 48);
                no /= 2;
            }
        }
        for (int j = 3 ; j >= 0 ; j--){
            binaryResult += temp[j];
        }
    }
    return binaryResult;
}
string convertBinToHex(string binText){
    stringstream res;
    string binary_str(binText);
    bitset<12> set(binary_str);
    res << hex << uppercase << set.to_ulong();
    return res.str();
}
bool all_num(string x)
{
  bool iall_num = true;
  int i = 0;
  while (all_num && (i < x.length()))
  {
    iall_num &= isdigit(x[i++]);
  }
  return iall_num;
}
void eval_operand(string s,bool& error,int& temp_value,string csect_name,int line){
    string str="",operand;temp_value=0; int abs=0;
    if(s[0]=='X'){//If value is given in hexadecimal 
        int ind=1;
        while(s[ind]!='\'')ind++;ind++;
        while(s[ind]!=' ')str+=s[ind++];
        temp_value=convertHexToDec(str);
    }else{
        stringstream ss(s);
        ss>>operand;
        if(all_num(operand)){
            temp_value+=stoi(operand);
        }else if(CSECT[csect_name].SYM_TAB[operand].exists){
            temp_value+=CSECT[csect_name].SYM_TAB[operand].address;abs++;
        }else{
            error=true;abs+=1000;
            cout<<"ERROR: LINE"<<line<<" "<<operand<<" is not defined in symbol table\n";
        }
        while(ss>>operand){
            char oprtr=operand[0];operand=operand.substr(1,operand.length()-1);
            switch(oprtr){
                case '+':   
                if(all_num(operand)){
                    temp_value+=stoi(operand);
                }else if(CSECT[csect_name].SYM_TAB[operand].exists){
                    temp_value+=CSECT[csect_name].SYM_TAB[operand].address;
                    abs++;
                }else{error=true;
                    cout<<"ERROR: LINE"<<line<<" "<<operand<<" is not defined in symbol table\n";
                }
                break;
                case '-':
                if(all_num(operand)){
                    temp_value-=stoi(operand);
                }else if(CSECT[csect_name].SYM_TAB[operand].exists){
                    temp_value-=CSECT[csect_name].SYM_TAB[operand].address;
                    abs--;
                }else{error=true;
                    cout<<"ERROR: LINE"<<line<<" "<<operand<<" is not defined in symbol table\n";
                }
                break;
                case '*':
                case '/':
                error=true;
                cout<<"ERROR: LINE"<<line<<" "<<oprtr<<" is not usable in expression\n";
                break;
                default:
                error=true;
                cout<<"ERROR: LINE"<<line<<" "<<oprtr<<" is not defined\n";
                break;
            }
        }
        if(abs!=0){
            error=true;
            cout<<"ERROR: LINE"<<line<<" is not absolute value\n";
        }
    }
}
void eaval_expression(string s,bool& absolute, bool& error,int& temp_val, string csect_name ){
    string str=s;
    temp_val=0;
    int rel=0;
    stringstream ss(str);
    set<char> oprtr; oprtr.insert('+');oprtr.insert('-');
    oprtr.insert('*');oprtr.insert('/');
    ss>>s;
    //search symbol tab for this s
    if(all_num(s)){
        temp_val+=stoi(s);
    }else{
        rel++;
    }
    while(ss>>s){
               //sym_tab substring if integer or value 
              if(s[0]=='+'){
                rel++;
              }else if(s[0]=='-'){
                rel--;
              }else if(s[0]=='*'){
                rel+=100;
              }else if(s[0]=='/'){
                rel+=100;
              }else{
                //undefined operator
                error=true;
                rel+=100;
              }       
    }
if(rel==0){
    cout<<"absolute"<<endl;
}else if(rel==1){
    cout<<"relative"<<endl;
}else {
    cout<<"invalid expression"<<endl;
}   
}
//initializer
void optab_init(){
  OP_TAB["ADD"].opcode = "18";
  OP_TAB["ADD"].format = 3;
  OP_TAB["ADD"].exists = true;

  OP_TAB["ADDF"].opcode = "58";
  OP_TAB["ADDF"].format = 3;
  OP_TAB["ADDF"].exists = true;

  OP_TAB["ADDR"].opcode = "90";
  OP_TAB["ADDR"].format = 2;
  OP_TAB["ADDR"].exists = true;

  OP_TAB["AND"].opcode = "40";
  OP_TAB["AND"].format = 3;
  OP_TAB["AND"].exists = true;

  OP_TAB["CLEAR"].opcode = "B4";
  OP_TAB["CLEAR"].format = 2;
  OP_TAB["CLEAR"].exists = true;

  OP_TAB["COMP"].opcode = "28";
  OP_TAB["COMP"].format = 3;
  OP_TAB["COMP"].exists = true;

  OP_TAB["COMPF"].opcode = "88";
  OP_TAB["COMPF"].format = 3;
  OP_TAB["COMPF"].exists = true;

  OP_TAB["COMPR"].opcode = "A0";
  OP_TAB["COMPR"].format = 2;
  OP_TAB["COMPR"].exists = true;

  OP_TAB["DIV"].opcode = "24";
  OP_TAB["DIV"].format = 3;
  OP_TAB["DIV"].exists = true;

  OP_TAB["DIVF"].opcode = "64";
  OP_TAB["DIVF"].format = 3;
  OP_TAB["DIVF"].exists = true;

  OP_TAB["DIVR"].opcode = "9C";
  OP_TAB["DIVR"].format = 2;
  OP_TAB["DIVR"].exists = true;

  OP_TAB["FIX"].opcode = "C4";
  OP_TAB["FIX"].format = 1;
  OP_TAB["FIX"].exists = true;

  OP_TAB["FLOAT"].opcode = "C0";
  OP_TAB["FLOAT"].format = 1;
  OP_TAB["FLOAT"].exists = true;

  OP_TAB["HIO"].opcode = "F4";
  OP_TAB["HIO"].format = 1;
  OP_TAB["HIO"].exists = true;

  OP_TAB["J"].opcode = "3C";
  OP_TAB["J"].format = 3;
  OP_TAB["J"].exists = true;

  OP_TAB["JEQ"].opcode = "30";
  OP_TAB["JEQ"].format = 3;
  OP_TAB["JEQ"].exists = true;

  OP_TAB["JGT"].opcode = "34";
  OP_TAB["JGT"].format = 3;
  OP_TAB["JGT"].exists = true;

  OP_TAB["JLT"].opcode = "38";
  OP_TAB["JLT"].format = 3;
  OP_TAB["JLT"].exists = true;

  OP_TAB["JSUB"].opcode = "48";
  OP_TAB["JSUB"].format = 3;
  OP_TAB["JSUB"].exists = true;

  OP_TAB["LDA"].opcode = "00";
  OP_TAB["LDA"].format = 3;
  OP_TAB["LDA"].exists = true;

  OP_TAB["LDB"].opcode = "68";
  OP_TAB["LDB"].format = 3;
  OP_TAB["LDB"].exists = true;

  OP_TAB["LDCH"].opcode = "50";
  OP_TAB["LDCH"].format = 3;
  OP_TAB["LDCH"].exists = true;

  OP_TAB["LDF"].opcode = "70";
  OP_TAB["LDF"].format = 3;
  OP_TAB["LDF"].exists = true;

  OP_TAB["LDL"].opcode = "08";
  OP_TAB["LDL"].format = 3;
  OP_TAB["LDL"].exists = true;

  OP_TAB["LDS"].opcode = "6C";
  OP_TAB["LDS"].format = 3;
  OP_TAB["LDS"].exists = true;

  OP_TAB["LDT"].opcode = "74";
  OP_TAB["LDT"].format = 3;
  OP_TAB["LDT"].exists = true;

  OP_TAB["LDX"].opcode = "04";
  OP_TAB["LDX"].format = 3;
  OP_TAB["LDX"].exists = true;

  OP_TAB["LPS"].opcode = "D0";
  OP_TAB["LPS"].format = 3;
  OP_TAB["LPS"].exists = true;

  OP_TAB["MUL"].opcode = "20";
  OP_TAB["MUL"].format = 3;
  OP_TAB["MUL"].exists = true;

  OP_TAB["MULF"].opcode = "60";
  OP_TAB["MULF"].format = 3;
  OP_TAB["MULF"].exists = true;

  OP_TAB["MULR"].opcode = "98";
  OP_TAB["MULR"].format = 2;
  OP_TAB["MULR"].exists = true;

  OP_TAB["NORM"].opcode = "C8";
  OP_TAB["NORM"].format = 1;
  OP_TAB["NORM"].exists = true;

  OP_TAB["OR"].opcode = "44";
  OP_TAB["OR"].format = 3;
  OP_TAB["OR"].exists = true;

  OP_TAB["RD"].opcode = "D8";
  OP_TAB["RD"].format = 3;
  OP_TAB["RD"].exists = true;

  OP_TAB["RMO"].opcode = "AC";
  OP_TAB["RMO"].format = 2;
  OP_TAB["RMO"].exists = true;

  OP_TAB["RSUB"].opcode = "4F";
  OP_TAB["RSUB"].format = 3;
  OP_TAB["RSUB"].exists = true;

  OP_TAB["SHIFTL"].opcode = "A4";
  OP_TAB["SHIFTL"].format = 2;
  OP_TAB["SHIFTL"].exists = true;

  OP_TAB["SHIFTR"].opcode = "A8";
  OP_TAB["SHIFTR"].format = 2;
  OP_TAB["SHIFTR"].exists = true;

  OP_TAB["SIO"].opcode = "F0";
  OP_TAB["SIO"].format = 1;
  OP_TAB["SIO"].exists = true;

  OP_TAB["SSK"].opcode = "EC";
  OP_TAB["SSK"].format = 3;
  OP_TAB["SSK"].exists = true;

  OP_TAB["STA"].opcode = "0C";
  OP_TAB["STA"].format = 3;
  OP_TAB["STA"].exists = true;

  OP_TAB["STB"].opcode = "78";
  OP_TAB["STB"].format = 3;
  OP_TAB["STB"].exists = true;

  OP_TAB["STCH"].opcode = "54";
  OP_TAB["STCH"].format = 3;
  OP_TAB["STCH"].exists = true;

  OP_TAB["STF"].opcode = "80";
  OP_TAB["STF"].format = 3;
  OP_TAB["STF"].exists = true;

  OP_TAB["STI"].opcode = "D4";
  OP_TAB["STI"].format = 3;
  OP_TAB["STI"].exists = true;

  OP_TAB["STL"].opcode = "14";
  OP_TAB["STL"].format = 3;
  OP_TAB["STL"].exists = true;

  OP_TAB["STS"].opcode = "7C";
  OP_TAB["STS"].format = 3;
  OP_TAB["STS"].exists = true;

  OP_TAB["STSW"].opcode = "E8";
  OP_TAB["STSW"].format = 3;
  OP_TAB["STSW"].exists = true;

  OP_TAB["STT"].opcode = "84";
  OP_TAB["STT"].format = 3;
  OP_TAB["STT"].exists = true;

  OP_TAB["STX"].opcode = "10";
  OP_TAB["STX"].format = 3;
  OP_TAB["STX"].exists = true;

  OP_TAB["SUB"].opcode = "1C";
  OP_TAB["SUB"].format = 3;
  OP_TAB["SUB"].exists = true;

  OP_TAB["SUBF"].opcode = "5C";
  OP_TAB["SUBF"].format = 3;
  OP_TAB["SUBF"].exists = true;

  OP_TAB["SUBR"].opcode = "94";
  OP_TAB["SUBR"].format = 2;
  OP_TAB["SUBR"].exists = true;

  OP_TAB["SVC"].opcode = "B0";
  OP_TAB["SVC"].format = 2;
  OP_TAB["SVC"].exists = true;

  OP_TAB["TD"].opcode = "E0";
  OP_TAB["TD"].format = 3;
  OP_TAB["TD"].exists = true;

  OP_TAB["TIO"].opcode = "F8";
  OP_TAB["TIO"].format = 1;
  OP_TAB["TIO"].exists = true;

  OP_TAB["TIX"].opcode = "2C";
  OP_TAB["TIX"].format = 3;
  OP_TAB["TIX"].exists = true;

  OP_TAB["TIXR"].opcode = "B8";
  OP_TAB["TIXR"].format = 2;
  OP_TAB["TIXR"].exists = true;

  OP_TAB["WD"].opcode = "DC";
  OP_TAB["WD"].format = 3;
  OP_TAB["WD"].exists = true;
}
void regtab_init()
{
  REG_TAB["A"].number = '0';
  REG_TAB["A"].exists = true;

  REG_TAB["X"].number = '1';
  REG_TAB["X"].exists = true;

  REG_TAB["L"].number = '2';
  REG_TAB["L"].exists = true;

  REG_TAB["B"].number = '3';
  REG_TAB["B"].exists = true;

  REG_TAB["S"].number = '4';
  REG_TAB["S"].exists = true;

  REG_TAB["T"].number = '5';
  REG_TAB["T"].exists = true;

  REG_TAB["F"].number = '6';
  REG_TAB["F"].exists = true;

  REG_TAB["PC"].number = '8';
  REG_TAB["PC"].exists = true;

  REG_TAB["SW"].number = '9';
  REG_TAB["SW"].exists = true;
}
//preprocess the input file
void preprocess(ifstream& in){
    set<char> oprtr; oprtr.insert('+');oprtr.insert('-');oprtr.insert('*');oprtr.insert('@');
    oprtr.insert('/');oprtr.insert('#');oprtr.insert(',');oprtr.insert('\'');oprtr.insert('=');
ofstream fout("preprocess.txt");
    string s,str,temp;
while(getline(in,s)){
    stringstream sfg(s);
    sfg>>temp;
if(temp[0]!='.'){
    bool fk=false;
    for(int i=0;i<s.length()-1;i++){
    if(s[i]==',' && s[i+1]!=' '){
        s.insert(i+1,1,' ');
    }
    }
    str=s;
    for(int i=0;i<s.length();i++){
        fk=(s[i]=='\'')?!fk:fk;
        if(!fk){
        str[i]=(char)toupper(s[i]);
        }
    }
    stringstream ss(str);    
    while(ss>>s){
        if(oprtr.find(s[0])==oprtr.end()){
            if(oprtr.find(s[s.length()-1])==oprtr.end()){
            fout<<s<<" ";
            }else{
                fout<<s.substr(0,s.length()-1)<<" "<<s[s.length()-1];
            }
        }else{
            if(s.length()==1)
            fout<<s;
            else fout<<s<<" ";
        }
        
    }
    fout<<"\n";
    }
}
}

//pass1
//assigning address to labels and identifying duplicate labels
void pass1(ifstream& in, bool& ferror){
    string label,opcode,operand;int operand_val=0,line=23;
    
    /* dummy values
    // CSECT["default"].SYM_TAB["BUFFER"].exists=true;
    // CSECT["default"].SYM_TAB["BUFFER"].isRelative=true;
    // CSECT["default"].SYM_TAB["BUFFER"].address=2;
    // CSECT["default"].SYM_TAB["BUFEND"].exists=true;
    // CSECT["default"].SYM_TAB["BUFEND"].isRelative=true;
    // CSECT["default"].SYM_TAB["BUFEND"].address=23;    
    // eval_operand(operand,ferror,operand_val,csect_name,line);
    // cout<<operand_val<<" "<<ferror<<endl;
    */
}
int main(){
    regtab_init();
    optab_init();
    ifstream in("input.txt");
    if(!in){
        cout<<"ERROR: could not open input file"<<endl;
        exit(1);
    }
    preprocess(in);
    in.close();
    in.open("preprocess.txt");
    bool ferror;
    pass1(in,ferror);
    return 0;
}